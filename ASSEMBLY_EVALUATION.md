# Assembly Evaluation Module

## Overview

The Assembly Evaluation module provides comprehensive tools for evaluating, refining, and analyzing genome assemblies generated by the ONT-Flye workflow. This module performs iterative alignment, repair, and finalization of assemblies, followed by read mapping and transgene detection.

## Workflow Phases

The module executes the following sequential phases:

### Phase 1: Initial Assembly Alignment

- **Process:** `ALIGN_ASSEMBLY_TO_GENOME`
- **Purpose:** Align raw assembly contigs to a wild-type reference genome
- **Tools:** minimap2 (asm5 preset) + samtools
- **Output:** Alignment table showing contig-to-chromosome mappings

### Phase 2: Assembly Repair

- **Process:** `REPAIR_ASSEMBLY`
- **Purpose:** Rename contigs to chromosomes and reverse-complement as needed
- **Script:** `repair_assembly.py` (requires BioPython)
- **Output:** Annotated assembly with proper contig orientation

### Phase 3: Annotated Assembly Alignment

- **Process:** `ALIGN_ANNOTATED_ASSEMBLY`
- **Purpose:** Verify repaired assembly alignment to reference
- **Tools:** minimap2 + samtools
- **Output:** Updated alignment table for annotated contigs

### Phase 4: Assembly Finalization

- **Process:** `FINALIZE_ASSEMBLY`
- **Purpose:** Concatenate multiple contigs per chromosome into final sequences
- **Script:** `final_assembly.py` (requires BioPython)
- **Output:** Final assembly with merged chromosomal sequences

### Phase 5: Final Assembly Validation

- **Process:** `ALIGN_FINAL_ASSEMBLY`
- **Purpose:** Final validation of assembled genome against reference
- **Tools:** minimap2 + samtools
- **Output:** Final alignment metrics

### Phase 6: Read Mapping

- **Process:** `MAP_READS_TO_ASSEMBLY`
- **Purpose:** Map original ONT reads back to final assembly
- **Tools:** minimap2 (map-ont preset) + samtools
- **Output:** Sorted BAM file with indexed reads

### Phase 7: Transgene Detection

- **Process:** `BLAST_TRANSGENE_TO_ASSEMBLY`
- **Purpose:** Identify transgene insertions in the final assembly
- **Tools:** BLAST (makeblastdb + blastn)
- **Output:** BLAST alignment results

### Phase 8: BED Format Conversion

- **Process:** `CONVERT_BLAST_TO_BED`
- **Purpose:** Convert BLAST results to genome browser-compatible format
- **Script:** `blast_to_bed.py`
- **Output:** BED file for visualization

### Phase 9 (Optional): Transcript Mapping

- **Process:** `MAP_TRANSCRIPTS_TO_ASSEMBLY`
- **Purpose:** Map known transcripts to the final assembly
- **Tools:** minimap2 + bedops (sam2bed)
- **Output:** BED file with transcript locations

## Usage

### Prerequisites

1. **Reference Genome:** Wild-type reference genome in FASTA format
2. **Assembled Genomes:** Output from the Flye assembly step
3. **Original Reads:** FASTQ files used for assembly
4. **Transgene Sequences:** FASTA file(s) with transgene sequences
5. **(Optional) Transcripts:** FASTA file with transcript sequences

### Configuration

Add the following to your workflow or set as command-line parameters:

```groovy
params {
    // Enable assembly evaluation
    run_assembly_evaluation = true
    
    // Required: Path to reference genome
    reference_genome = "/path/to/WT_mito.fa"
    
    // Optional: Transcripts for mapping
    transcripts_fasta = "/path/to/phaffi_transcripts.fa"
    
    // Coverage thresholds (if filtering assemblies)
    min_assembly_depth = 20
    max_assembly_depth = 100
}
```

### Integration into Workflow

In your main workflow file (`workflows/ont_flye.nf`), add:

```groovy
// Include assembly evaluation processes
include { ALIGN_ASSEMBLY_TO_GENOME } from '../modules/local/assembly_evaluation'
include { REPAIR_ASSEMBLY } from '../modules/local/assembly_evaluation'
include { ALIGN_ANNOTATED_ASSEMBLY } from '../modules/local/assembly_evaluation'
include { FINALIZE_ASSEMBLY } from '../modules/local/assembly_evaluation'
include { ALIGN_FINAL_ASSEMBLY } from '../modules/local/assembly_evaluation'
include { MAP_READS_TO_ASSEMBLY } from '../modules/local/assembly_evaluation'
include { BLAST_TRANSGENE_TO_ASSEMBLY } from '../modules/local/assembly_evaluation'
include { CONVERT_BLAST_TO_BED } from '../modules/local/assembly_evaluation'
include { MAP_TRANSCRIPTS_TO_ASSEMBLY } from '../modules/local/assembly_evaluation'

// After FLYE assembly step, add:
if (params.run_assembly_evaluation && params.reference_genome) {
    // Prepare reference genome channel
    reference_genome = file(params.reference_genome, checkIfExists: true)
    
    // Phase 1: Initial alignment
    assembly_with_ref = FLYE.out.assembly_fasta
        .map { sample_name, assembly_fasta -> 
            [sample_name, assembly_fasta, reference_genome]
        }
    
    ALIGN_ASSEMBLY_TO_GENOME(assembly_with_ref)
    
    // Phase 2: Repair assembly
    REPAIR_ASSEMBLY(ALIGN_ASSEMBLY_TO_GENOME.out.alignment)
    
    // Phase 3: Align repaired assembly
    annotated_with_ref = REPAIR_ASSEMBLY.out.annotated_assembly
        .map { sample_name, annotated_fasta ->
            [sample_name, annotated_fasta, reference_genome]
        }
    
    ALIGN_ANNOTATED_ASSEMBLY(annotated_with_ref)
    
    // Phase 4: Finalize assembly
    FINALIZE_ASSEMBLY(ALIGN_ANNOTATED_ASSEMBLY.out.alignment)
    
    // Phase 5: Final alignment
    final_with_ref = FINALIZE_ASSEMBLY.out.final_assembly
        .map { sample_name, final_fasta ->
            [sample_name, final_fasta, reference_genome]
        }
    
    ALIGN_FINAL_ASSEMBLY(final_with_ref)
    
    // Phase 6: Map reads to assembly
    // Match final assemblies with their original FASTQ files
    final_with_reads = FINALIZE_ASSEMBLY.out.final_assembly
        .combine(all_processed_fastq)
        .filter { final_sample, _final_fasta, fastq_sample, _fastq_file ->
            fastq_sample == final_sample
        }
        .map { final_sample, final_fasta, _fastq_sample, fastq_file ->
            [final_sample, final_fasta, fastq_file]
        }
    
    MAP_READS_TO_ASSEMBLY(final_with_reads)
    
    // Phase 7-8: Transgene detection
    // Combine with transgene info (similar to existing TRANSGENE_BLAST logic)
    final_with_transgene = FINALIZE_ASSEMBLY.out.final_assembly
        .combine(input_ch.map { sample_name, _fastq, transgene_name, _size_ranges, _downsample_rates -> 
            [sample_name, transgene_name] 
        })
        .filter { assembly_sample, _assembly_fasta, input_sample, _transgene_name ->
            assembly_sample.startsWith(input_sample.split('_')[0])
        }
        .map { assembly_sample, assembly_fasta, _input_sample, transgene_name ->
            [assembly_sample, assembly_fasta, transgene_name]
        }
    
    // Join with transgene files
    eval_blast_input = final_with_transgene
        .combine(transgene_ch)
        .filter { _sample, _fasta, tg_name, tg_file_name, _tg_file ->
            tg_name == tg_file_name
        }
        .map { sample, fasta, tg_name, _tg_file_name, tg_file ->
            [sample, fasta, tg_name, tg_file]
        }
    
    BLAST_TRANSGENE_TO_ASSEMBLY(eval_blast_input)
    
    // Convert to BED
    blast_with_name = BLAST_TRANSGENE_TO_ASSEMBLY.out.blast_results
        .map { sample_name, blast_file ->
            def transgene_name = sample_name.split('_')[-1]
            [sample_name, blast_file, transgene_name]
        }
    
    CONVERT_BLAST_TO_BED(blast_with_name)
    
    // Phase 9 (Optional): Transcript mapping
    if (params.transcripts_fasta) {
        transcripts = file(params.transcripts_fasta, checkIfExists: true)
        
        final_with_transcripts = FINALIZE_ASSEMBLY.out.final_assembly
            .map { sample_name, final_fasta ->
                [sample_name, final_fasta, transcripts]
            }
        
        MAP_TRANSCRIPTS_TO_ASSEMBLY(final_with_transcripts)
    }
}
```

## Output Structure

```{text}
results/
└── assembly_evaluation/
    └── <sample_name>/
        ├── alignments/
        │   ├── <sample>_assembly_to_genome.txt
        │   ├── <sample>_annotated_assembly_to_genome.txt
        │   └── <sample>_final_assembly_to_genome.txt
        ├── repaired/
        │   ├── <sample>_annotated_assembly.fasta
        │   └── <sample>_repair_assembly.log
        ├── final/
        │   ├── <sample>_final_assembly.fasta
        │   └── <sample>_finalize_assembly.log
        ├── read_mapping/
        │   ├── <sample>_ont_to_assembled.sorted.bam
        │   └── <sample>_ont_to_assembled.sorted.bam.bai
        ├── transgene_blast/
        │   ├── <sample>_<transgene>_transgene_blast.txt
        │   └── <sample>_<transgene>_transgene_blast.bed
        └── transcript_mapping/ (optional)
            ├── <sample>_transcripts_to_assembly.sam
            └── <sample>_transcripts_to_assembly.bed
```

## Container Requirements

The module uses the following containers (automatically pulled by Nextflow):

1. **General Genomics Tools (Minimap2, Samtools, BioPython, Bedtools):**
   - `bumproo/general_genomics:latest`
   - Used for: alignment, repair, finalization, read mapping, and transcript mapping

2. **BLAST:**
   - `ncbi/blast:latest`
   - Used for: transgene detection

## Python Scripts

The module relies on three Python scripts in the `bin/` directory:

1. **`repair_assembly.py`** - Repairs contig orientation based on reference alignment
2. **`final_assembly.py`** - Concatenates contigs into final chromosomal sequences
3. **`blast_to_bed.py`** - Converts BLAST output to BED format

These scripts are automatically available in the PATH when processes execute.

## Resource Usage

Default resource allocations (can be adjusted in `nextflow.config`):

| Process | CPUs | Memory | Time |
| --------- | ------ | -------- | ------ |
| ALIGN_ASSEMBLY_TO_GENOME | 4 | 16 GB | 2h |
| REPAIR_ASSEMBLY | 1 | 8 GB | 1h |
| ALIGN_ANNOTATED_ASSEMBLY | 4 | 16 GB | 2h |
| CALCULATE_CHROMOSOME_COVERAGE | 4 | 16 GB | 2h |
| CONSOLIDATE_COVERAGE_SUMMARY | 1 | 2 GB | 30m |
| FINALIZE_ASSEMBLY | 1 | 8 GB | 1h |
| ALIGN_FINAL_ASSEMBLY | 4 | 16 GB | 2h |
| MAP_READS_TO_ASSEMBLY | 8 | 32 GB | 4h |
| BLAST_TRANSGENE_TO_ASSEMBLY | 2 | 8 GB | 1h |
| CONVERT_BLAST_TO_BED | 1 | 2 GB | 30m |
| MAP_TRANSCRIPTS_TO_ASSEMBLY | 4 | 16 GB | 2h |

## Troubleshooting

### Issue: BioPython not found

**Solution:** The `bumproo/general_genomics:latest` container includes BioPython. Ensure you're using the correct container specification in `nextflow.config`.

### Issue: Reference genome not found

**Solution:** Verify `params.reference_genome` points to a valid file path. Use absolute paths or paths relative to the workflow launch directory.

### Issue: sam2bed command not found

**Solution:** The `bumproo/general_genomics:latest` container includes bedops tools. Ensure the process is using the correct container.

### Issue: Assembly contigs don't align

**Solution:** Check that your reference genome is appropriate for your assembly. Use minimap2 asm5 preset for close-reference assemblies or asm10/asm20 for more divergent assemblies.

## Advanced Usage

### Customizing Alignment Parameters

You can add custom parameters using process directives:

```groovy
process {
    withName: 'ALIGN_ASSEMBLY_TO_GENOME' {
        ext.args = '-K 500M'  // Additional minimap2 flags
    }
}
```

### Running Only Specific Phases

You can selectively run phases by importing only needed processes and creating custom workflows.

### Batch Processing

The module is designed to work with the existing sample batch processing. All samples in your `samples.csv` will be evaluated if `run_assembly_evaluation = true`.

## Citation

If you use this module, please cite:

- **Minimap2:** Li, H. (2018). Minimap2: pairwise alignment for nucleotide sequences. Bioinformatics, 34:3094-3100.
- **Samtools:** Danecek et al. (2021). Twelve years of SAMtools and BCFtools. GigaScience, 10(2):giab008.
- **BLAST:** Camacho et al. (2009). BLAST+: architecture and applications. BMC Bioinformatics, 10:421.
- **BioPython:** Cock et al. (2009). Biopython: freely available Python tools for computational molecular biology and bioinformatics. Bioinformatics, 25(11):1422-1423.
