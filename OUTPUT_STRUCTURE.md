# Output Structure Documentation

Complete reference for all output files generated by the yeast-integrant-eval workflow.

## Table of Contents

- [Directory Overview](#directory-overview)
- [Pipeline Information](#pipeline-information)
- [Quality Control Outputs](#quality-control-outputs)
- [Filtered Reads](#filtered-reads)
- [Downsampled Reads](#downsampled-reads)
- [Assembly Preflight](#assembly-preflight)
- [Assemblies](#assemblies)
- [Transgene Detection](#transgene-detection)
- [Summary Files](#summary-files)
- [Assembly Evaluation (Optional)](#assembly-evaluation-optional)

## Directory Overview

```text
results/
├── pipeline_info/           # Nextflow execution reports
├── nanoplot/               # Quality control reports  
├── chopper/                # Quality and size-filtered reads
├── downsample/             # Downsampled read sets
├── flye_preflight/         # Assembly candidate evaluation
├── flye/                   # De novo assemblies
├── blast/                  # Transgene detection results
├── summary/                # Aggregated statistics
└── assembly_evaluation/    # Optional reference-based validation
```

## Pipeline Information

**Location:** `results/pipeline_info/`

Nextflow automatically generates execution reports for monitoring and troubleshooting.

### execution_timeline.html

**Format:** Interactive HTML

**Contents:**

- Visual timeline of all process executions
- Start/end times for each task
- Duration bars color-coded by process type
- Parallelization visualization

**Use cases:**

- Identify bottlenecks in workflow
- Understand execution order
- Optimize resource allocation

### execution_report.html

**Format:** Interactive HTML report

**Contents:**

- **Summary statistics**: Total runtime, CPU hours, memory usage
- **Resource usage**: CPU efficiency, memory efficiency per process
- **Task details**: Individual task metrics and status
- **Resource plots**: Visual representation of resource consumption

**Key metrics to check:**

- **CPU efficiency**: Should be >80% for well-configured processes
- **Memory usage**: Identify processes that need more RAM
- **Task duration**: Find slow steps that need optimization

### execution_trace.txt

**Format:** Tab-separated values (TSV)

**Columns:**

- `task_id`: Unique task identifier
- `hash`: Task hash for caching
- `process`: Process name
- `status`: COMPLETED, FAILED, CACHED
- `cpus`, `memory`, `time`: Resource usage
- `realtime`, `%cpu`, `%mem`: Actual utilization

**Use cases:**

- Machine-readable execution data
- Custom analysis scripts
- Resource optimization studies

### pipeline_dag.svg

**Format:** SVG image

**Contents:**

- Directed acyclic graph (DAG) of workflow
- Shows process dependencies
- Visualizes data flow

**Use cases:**

- Understand workflow structure
- Identify parallelization opportunities
- Documentation and presentations

## Quality Control Outputs

**Location:** `results/nanoplot/`

NanoPlot generates comprehensive QC reports for each FASTQ file processed.

### Directory Structure

```text
nanoplot/
├── <sample>_original/              # Original FASTQ QC
│   ├── NanoPlot-report.html        # Main HTML report
│   ├── NanoStats.txt               # Summary statistics
│   ├── LengthvsQualityScatterPlot_dot.png
│   ├── LengthvsQualityScatterPlot_kde.png
│   ├── Non_weightedHistogramReadlength.png
│   ├── Non_weightedLogTransformed_HistogramReadlength.png
│   ├── WeightedHistogramReadlength.png
│   └── WeightedLogTransformed_HistogramReadlength.png
│
└── <sample>_<size_range>/          # Filtered FASTQ QC
    └── [same files as above]
```

### NanoPlot-report.html

**Format:** Interactive HTML report

**Key sections:**

1. **Summary Statistics**
   - Total bases
   - Number of reads
   - Mean/median read length
   - Mean/median quality score
   - N50 read length

2. **Read Length Distribution**
   - Histogram of read lengths
   - Shows effect of filtering

3. **Read Quality Distribution**
   - Quality score histogram
   - Length vs quality scatter plot

4. **Plots**
   - Weighted/unweighted histograms
   - Log-transformed distributions
   - Scatter plots with KDE overlays

**Interpretation:**

| Metric | Good | Concerning |
| -------- | ------ | ------------ |
| Mean quality | >12 | <10 |
| Mean length (40kb+ filter) | >45 kb | <35 kb |
| Total bases | >500 Mb | <100 Mb |
| N50 read length | >50 kb | <30 kb |

### NanoStats.txt

**Format:** Plain text, key-value pairs

**Example:**

```text
Mean read length:                45234.5
Mean read quality:               12.8
Median read length:              43021.0
Median read quality:             13.1
Number of reads:                 12543
Total bases:                     567432100
N50:                             51234
```

**Use cases:**

- Quick command-line inspection
- Automated QC checks
- Parsing into analysis scripts

## Filtered Reads

**Location:** `results/chopper/`

Reads filtered by quality (Q≥10) and size thresholds.

### Chopper Directory Structure

```text
chopper/
└── <sample>_<size_range>/
    └── filtered_reads.fastq.gz
```

**Example:**

```text
chopper/
├── sample_001_40k_Plus/
│   └── filtered_reads.fastq.gz
└── sample_001_50k_Plus/
    └── filtered_reads.fastq.gz
```

### filtered_reads.fastq.gz

**Format:** Compressed FASTQ

**Contents:**

- Reads passing quality threshold (Q≥10)
- Reads passing minimum length threshold
- Original read names and quality scores preserved

**Size:** Typically 20-60% of original FASTQ size

**Use cases:**

- Input for downstream assemblies
- QC validation
- Archiving processed data

## Downsampled Reads

**Location:** `results/downsample/`

Random subsets of filtered reads at specified fractions.

### Downsample Directory Structure

```text
downsample/
└── <sample>_<size>_ds<rate>_rep<N>/
    └── downsampled_reads.fastq.gz
```

**Example:**

```text
downsample/
├── sample_001_40k_Plus_ds0.25_rep1/
│   └── downsampled_reads.fastq.gz
├── sample_001_40k_Plus_ds0.25_rep2/
│   └── downsampled_reads.fastq.gz
├── sample_001_40k_Plus_ds0.5_rep1/
│   └── downsampled_reads.fastq.gz
└── sample_001_50k_Plus_ds0.25_rep1/
    └── downsampled_reads.fastq.gz
```

### downsampled_reads.fastq.gz

**Format:** Compressed FASTQ

**Contents:**

- Random subset of filtered reads
- Fraction determined by `ds<rate>` parameter
- Replicate number indicates independent random sampling
- Reproducible via seed (seed = replicate number)

**Expected size:**

- ds0.25: ~25% of filtered FASTQ
- ds0.5: ~50% of filtered FASTQ
- ds0.75: ~75% of filtered FASTQ

**Use cases:**

- Coverage optimization studies
- Assembly robustness testing
- Statistical analysis with replicates

## Assembly Preflight

**Location:** `results/flye_preflight/`

Fast coverage estimation to filter assembly candidates.

### assembly_candidates.csv

**Format:** CSV

**Columns:**

- `sample_name`: Sample identifier with conditions
- `fastq_path`: Path to FASTQ file
- `estimated_depth`: Estimated sequencing coverage
- `status`: "candidate" (passed thresholds)

**Example:**

```csv
sample_name,fastq_path,estimated_depth,status
sample_001_40k_Plus,/path/to/filtered.fastq.gz,75.3,candidate
sample_001_40k_Plus_ds0.5_rep1,/path/to/downsampled.fastq.gz,37.6,candidate
sample_002_50k_Plus_ds0.25_rep1,/path/to/downsampled.fastq.gz,23.1,candidate
```

**Interpretation:**

- These samples **will proceed** to full Flye assembly
- Coverage estimates guide assembly quality expectations

### assembly_filtered.csv

**Format:** CSV

**Columns:**

- `sample_name`: Sample identifier
- `fastq_path`: Path to FASTQ file
- `estimated_depth`: Estimated sequencing coverage
- `status`: "filtered" (did not pass)
- `reason`: Why sample was filtered

**Example:**

```csv
sample_name,fastq_path,estimated_depth,status,reason
sample_003_30k_Plus,/path/to/filtered.fastq.gz,15.2,filtered,Below minimum depth (15.2 < 20)
sample_004_40k_Plus,/path/to/filtered.fastq.gz,250.8,filtered,Above maximum depth (250.8 > 100)
```

**Common reasons:**

- `Below minimum depth (X < Y)`: Insufficient coverage
- `Above maximum depth (X > Y)`: Excessive coverage (may cause issues)

**Use cases:**

- Identify low-coverage samples needing more sequencing
- Detect over-sequenced samples
- Adjust `min_assembly_depth` / `max_assembly_depth` parameters

### Individual Preflight Logs

**Files:** `results/flye_preflight/<sample>/flye_preflight.log`

**Format:** Plain text log

**Contents:**

- Flye preflight execution details
- Read statistics
- Coverage estimation details
- Memory and time usage

**Use cases:**

- Debugging preflight failures
- Detailed coverage analysis

## Assemblies

**Location:** `results/flye/`

De novo genome assemblies generated by Flye.

### Flye Directory Structure

```text
flye/
└── <sample_with_conditions>/
    ├── assembly.fasta
    ├── assembly_info.txt
    ├── assembly_graph.gfa
    ├── assembly_graph.gv
    ├── flye.log
    └── params.json
```

**Example:**

```text
flye/
├── sample_001_40k_Plus/
├── sample_001_40k_Plus_ds0.5_rep1/
├── sample_001_50k_Plus/
└── sample_002_40k_Plus_ds0.25_rep1/
```

### assembly.fasta

**Format:** FASTA

**Contents:**

- Final assembled contigs
- Contig names: `contig_1`, `contig_2`, etc.
- Headers may include length and coverage information

**Example:**

```fasta
>contig_1 len=1531728 cov=72 circular=yes
ATGCGATCGATCG...
>contig_2 len=924561 cov=68 circular=no
GCTAGCTAGCTA...
```

**Header annotations:**

- `len`: Contig length in base pairs
- `cov`: Estimated coverage
- `circular`: Whether contig forms a circle (yes/no)

**Expected for yeast:**

- Total size: 10-15 Mb
- Contigs: 5-50 (fewer is better)
- Circular contigs: Chromosomes or plasmids

### assembly_info.txt

**Format:** Tab-separated values

**Columns:**

- `#seq_name`: Contig name
- `length`: Contig length (bp)
- `cov.`: Coverage estimate
- `circ.`: Circular topology (Y/N)
- `repeat`: Repeat classification
- `mult.`: Multiplicity
- `alt_group`: Alternative assembly group
- `graph_path`: Path in assembly graph

**Example:**

```text
#seq_name    length      cov.    circ.   repeat  mult.   alt_group   graph_path
contig_1     1531728     72      Y       N       1       *           1
contig_2     924561      68      N       N       1       *           2
contig_3     812345      65      N       N       1       *           3
```

**Use cases:**

- Quick assembly statistics
- Identify circular contigs (chromosomes)
- Check coverage uniformity
- Detect repeat regions

### assembly_graph.gfa

**Format:** GFA (Graphical Fragment Assembly)

**Contents:**

- Assembly graph structure
- Contig sequences and connections
- Overlap information

**Use cases:**

- Visualization with Bandage
- Understanding assembly structure
- Identifying complex regions

**Viewing with Bandage:**

```bash
Bandage load results/flye/sample_001_40k_Plus/assembly_graph.gfa
```

### flye.log

**Format:** Plain text log

**Contents:**

- Complete Flye execution log
- Read statistics
- Assembly stages
- Error messages (if any)

**Key sections to check:**

1. **Input reads summary**

   ```text
   [2024-01-15 10:23:45] INFO: Reads N50/N90: 45234 / 32156
   [2024-01-15 10:23:45] INFO: Total read length: 567432100
   ```

2. **Assembly graph statistics**

   ```text
   [2024-01-15 11:15:23] INFO: Assembled 15 contigs
   [2024-01-15 11:15:23] INFO: Total length: 12345678
   ```

3. **Completion status**

   ```text
   [2024-01-15 12:05:12] INFO: Assembly complete
   ```

## Transgene Detection

**Location:** `results/blast/`

BLAST-based transgene detection and copy number estimation.

### Blast Directory Structure

```text
blast/
└── <sample>_<transgene>/
    ├── blast_results.txt
    └── blast_summary.csv
```

**Example:**

```text
blast/
├── sample_001_40k_Plus_A-vector_herceptin_pEY345/
│   ├── blast_results.txt
│   └── blast_summary.csv
└── sample_002_50k_Plus_superfolder_GFP/
    ├── blast_results.txt
    └── blast_summary.csv
```

### blast_results.txt

**Format:** BLAST tabular output (outfmt 6 with custom fields)

**Columns:**

1. `qseqid`: Query sequence ID (transgene)
2. `sseqid`: Subject sequence ID (contig)
3. `pident`: Percent identity
4. `length`: Alignment length
5. `mismatch`: Number of mismatches
6. `gapopen`: Number of gap openings
7. `qstart`: Query start position
8. `qend`: Query end position
9. `sstart`: Subject start position
10. `send`: Subject end position
11. `evalue`: E-value
12. `bitscore`: Bit score
13. `qlen`: Query length
14. `slen`: Subject length
15. `qcovs`: Query coverage per subject

**Example:**

```text
transgene_1 contig_3 99.85 6543 10 0 1 6543 123456 130000 0.0 12045 6543 1531728 100
transgene_1 contig_7 98.21 6501 115 2 1 6500 45678 52178 0.0 11523 6543 412567 99.3
```

**Interpretation:**

- High `pident` (>95%): Good match
- High `qcovs` (>95%): Nearly complete transgene
- Multiple hits: Multiple integrations or partial copies

### blast_summary.csv

**Format:** CSV

**Columns:**

- `sample_name`: Sample identifier
- `transgene`: Transgene name
- `num_hits`: Number of BLAST alignments
- `copy_number_estimate`: Estimated copy number
- `total_coverage`: Total bases aligned
- `best_hit_identity`: Highest percent identity
- `best_hit_coverage`: Highest query coverage

**Example:**

```csv
sample_name,transgene,num_hits,copy_number_estimate,total_coverage,best_hit_identity,best_hit_coverage
sample_001_40k_Plus,A-vector_herceptin_pEY345,2,2.1,13845,99.85,100.0
sample_002_50k_Plus,superfolder_GFP,1,1.0,714,99.72,100.0
sample_003_30k_Plus,E1_boNT,3,1.8,8234,98.45,95.3
```

**Copy number interpretation:**

- ~1.0: Single integration
- ~2.0: Two copies (tandem or separate loci)
- ~0.5: Partial integration or contamination
- >3.0: Multiple integrations or amplification

**Quality indicators:**

- `best_hit_identity` >98%: High-confidence detection
- `best_hit_coverage` >95%: Complete or nearly complete transgene
- `total_coverage` > transgene length: Multiple copies

## Summary Files

**Location:** `results/summary/`

Aggregated results from all samples and conditions.

### assembly_stats_summary.csv

**Format:** CSV

**Columns:**

- `sample_name`: Sample identifier with all conditions
- `total_length`: Total assembly size (bp)
- `num_contigs`: Number of contigs
- `largest_contig`: Largest contig size (bp)
- `N50`: N50 metric (bp)
- `L50`: L50 metric (number of contigs)
- `circular_contigs`: Number of circular contigs
- `mean_coverage`: Mean coverage across all contigs

**Example:**

```csv
sample_name,total_length,num_contigs,largest_contig,N50,L50,circular_contigs,mean_coverage
sample_001_40k_Plus,12034567,12,1531728,945234,4,3,72.5
sample_001_40k_Plus_ds0.5_rep1,11987234,15,1489012,892156,5,2,36.8
sample_001_50k_Plus,12123456,9,1598234,1034567,3,4,68.3
sample_002_40k_Plus,11756892,18,1234567,756234,6,1,54.2
```

**Use cases:**

- Compare assemblies across conditions
- Identify optimal parameters
- Statistical analysis of replicates
- Quality assessment

**Key metrics:**

| Metric | Good (Yeast) | Needs Attention |
| -------- | -------------- | ----------------- |
| total_length | 10-15 Mb | <9 or >16 Mb |
| num_contigs | <20 | >50 |
| N50 | >800 kb | <300 kb |
| circular_contigs | ≥1 | 0 |

### blast_results_summary.csv

**Format:** CSV

Aggregated transgene detection results for all samples.

**Columns:**

- `sample_name`: Sample identifier
- `transgene`: Transgene detected
- `num_hits`: Number of BLAST hits
- `copy_number_estimate`: Estimated copies
- `total_coverage`: Total aligned bases
- `best_hit_identity`: Best percent identity
- `best_hit_coverage`: Best query coverage
- `contig_names`: List of contigs with hits

**Example:**

```csv
sample_name,transgene,num_hits,copy_number_estimate,total_coverage,best_hit_identity,best_hit_coverage,contig_names
sample_001_40k_Plus,herceptin,2,2.1,13845,99.85,100.0,"contig_3,contig_7"
sample_001_40k_Plus_ds0.5_rep1,herceptin,2,2.0,13776,99.81,100.0,"contig_4,contig_9"
sample_002_50k_Plus,GFP,1,1.0,714,99.72,100.0,contig_2
```

**Use cases:**

- Compare copy numbers across conditions
- Validate consistency of replicates
- Identify integration patterns

## Assembly Evaluation (Optional)

**Location:** `results/assembly_evaluation/`

**Note:** Only present if `--run_assembly_evaluation true` is specified.

See [ASSEMBLY_EVALUATION.md](ASSEMBLY_EVALUATION.md) for complete documentation.

### Assembly Evaluation Directory Structure

```text
assembly_evaluation/
└── <sample>/
    ├── alignments/
    │   ├── <sample>_assembly_to_genome.txt
    │   ├── <sample>_annotated_assembly_to_genome.txt
    │   └── <sample>_final_assembly_to_genome.txt
    ├── repaired/
    │   ├── <sample>_annotated_assembly.fasta
    │   └── <sample>_repair_assembly.log
    ├── final/
    │   ├── <sample>_final_assembly.fasta
    │   └── <sample>_finalize_assembly.log
    ├── read_mapping/
    │   ├── <sample>_ont_to_assembled.sorted.bam
    │   └── <sample>_ont_to_assembled.sorted.bam.bai
    ├── transgene_blast/
    │   ├── <sample>_<transgene>_transgene_blast.txt
    │   └── <sample>_<transgene>_transgene_blast.bed
    └── transcript_mapping/
        ├── <sample>_transcripts_to_assembly.sam
        └── <sample>_transcripts_to_assembly.bed
```

### Key Files

#### Final Assembly (Evaluated)

**File:** `final/<sample>_final_assembly.fasta`

**Format:** FASTA with chromosome names

**Contents:**

- Reference-oriented contigs
- Merged chromosomes (if multiple contigs per chromosome)
- Properly oriented sequences

**Example:**

```fasta
>chr1
ATGCGATCGATCG...
>chr2  
GCTAGCTAGCTA...
>chrM
TGATCGATCGAT...
```

#### Read Mapping (for IGV)

**File:** `read_mapping/<sample>_ont_to_assembled.sorted.bam`

**Format:** Binary alignment (BAM)

**Contents:**

- ONT reads mapped to final assembly
- Sorted and indexed for visualization

**Use with IGV:**

```bash
# Load assembly FASTA as reference
# Load BAM file as track
# Load BED files for annotations
```

#### Transgene Locations (BED)

**File:** `transgene_blast/<sample>_<transgene>_transgene_blast.bed`

**Format:** BED (Browser Extensible Data)

**Columns:**

1. Chromosome/contig name
2. Start position (0-based)
3. End position
4. Feature name (transgene)
5. Score (BLAST identity * 10)
6. Strand (+/-)

**Example:**

```text
chr3 123456 130000 herceptin_hit1 998 +
chr7 45678 52178 herceptin_hit2 982 -
```

**Use cases:**

- IGV visualization
- Genome browser display
- Integration site analysis

## File Size Guidelines

Approximate file sizes for typical yeast genome analysis:

| File Type | Typical Size | Notes |
| ----------- | -------------- | ------- |
| Original FASTQ | 2-10 GB | Depends on coverage |
| Filtered FASTQ | 1-6 GB | 20-60% of original |
| Downsampled FASTQ | 0.25-6 GB | Depends on rate |
| NanoPlot reports | 5-10 MB | Per FASTQ |
| Assembly FASTA | 10-15 MB | ~12 Mb for yeast |
| Assembly graph (GFA) | 20-50 MB | Includes overlaps |
| BAM file | 1-5 GB | Depends on coverage |
| Summary CSVs | <1 MB | Very small |

**Total storage requirements:**

- Single sample, single condition: ~5-15 GB
- Single sample, multiple conditions: ~20-60 GB
- Batch (10 samples): ~100-300 GB
- With replicates and evaluation: Multiply by 2-3x

## Data Retention Recommendations

### Keep Long-Term

✅ Original FASTQ files (archive separately)
✅ Final assemblies (assembly.fasta)
✅ Assembly statistics (assembly_info.txt)
✅ Transgene detection (blast_summary.csv)
✅ Summary files (summary/*.csv)
✅ Pipeline reports (pipeline_info/)

### Optional After Validation

⚙️ Filtered FASTQs (can regenerate)
⚙️ Downsampled FASTQs (can regenerate)
⚙️ NanoPlot reports (can regenerate)
⚙️ Assembly graphs (large, can regenerate)

### Safe to Delete After Analysis

❌ Work directories
❌ Intermediate files
❌ Cached processes (`.nextflow/`)

## Accessing Results Programmatically

### Python Example

```python
import pandas as pd

# Load assembly statistics
assembly_stats = pd.read_csv('results/summary/assembly_stats_summary.csv')

# Filter for high-quality assemblies
good_assemblies = assembly_stats[
    (assembly_stats['total_length'] > 10e6) &
    (assembly_stats['total_length'] < 15e6) &
    (assembly_stats['num_contigs'] < 20) &
    (assembly_stats['N50'] > 500000)
]

# Load transgene results
blast_results = pd.read_csv('results/summary/blast_results_summary.csv')

# Calculate mean copy number across replicates
mean_copies = blast_results.groupby('sample_name')['copy_number_estimate'].agg(['mean', 'std'])
```

### R Example

```r
library(tidyverse)

# Load assembly statistics
assembly_stats <- read_csv('results/summary/assembly_stats_summary.csv')

# Compare N50 across conditions
assembly_stats %>%
  filter(str_detect(sample_name, 'sample_001')) %>%
  ggplot(aes(x = sample_name, y = N50)) +
  geom_bar(stat = 'identity') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Bash Example

```bash
# Count assemblies by condition
cut -d',' -f1 results/summary/assembly_stats_summary.csv | \
  grep -E '40k|50k' | \
  sed 's/_rep.*//' | \
  sort | \
  uniq -c

# Extract best assemblies
awk -F',' '$3 < 20 && $5 > 500000' results/summary/assembly_stats_summary.csv
```

## Related Documentation

- **Main README:** [README.md](README.md)
- **Usage Guide:** [USAGE_GUIDE.md](USAGE_GUIDE.md)
- **Assembly Evaluation:** [ASSEMBLY_EVALUATION.md](ASSEMBLY_EVALUATION.md)
- **Depth Configuration:** [QUICK_START_DEPTH_CONFIG.md](QUICK_START_DEPTH_CONFIG.md)
